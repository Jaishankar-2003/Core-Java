Collection Interface in Java
====================================

Collection interface in Java is the root interface of the Java Collection Framework (JCF).

It defines a group of objects known as elements and provides basic operations for working with them.

The interface is part of the java.util package

forms the foundation for most collection classes, including List, Set, and Queue.


@@@@@@@
Root interface of all standard collections.
Not directly implemented. Instead, subclasses like ArrayList, HashSet, and LinkedList implement it


Sub-Interfaces of Collection Interface
-----------------------------------------
1. List :  allow duplicates

List represents an ordered collection that allows duplicates.
                            -----------------------------------
Elements can be accessed by index.
Implementing Classes: **** ArrayList, LinkedList, Vector, Stack. ****
                           ======================================

2. Set : no duplicates allowed

Set represents an unordered collection with no duplicate elements.
                            -----------------------------------------
Implementing Classes: *** HashSet, TreeSet, LinkedHashSet, EnumSet, CopyOnWriteArraySet. ***
                        =================================================================

3. SortedSet :  set & maintail element sorted order

SortedSet extends Set and maintains elements in a sorted order.
                  -----------------------------------------------
Provides methods to handle range-based operations.
Implementing Class: TreeSet.
                   ==========

4. NavigableSet

NavigableSet extends SortedSet and provides navigation methods like lower(), floor(), ceiling(), and higher().
                    ------------------------------------------------------------------------------------------
Implementing Class: TreeSet.
                    =========

5. Queue : FIFO

Queue represents a collection following FIFO (First-In-First-Out) order.

Implementing Classes: PriorityQueue, Deque, ArrayDeque, LinkedList
                      =============================================

5. Deque  :  Add / Remove in both ends

Deque extends Queueallows elements to be added/removed from both ends.
              ----------------------------------------------==============
Implementing Classes: ArrayDeque, LinkedList.
                     ==========================

================================================================================================================================
Array List
================

1. ArrayList(): This constructor is used to build an empty array list.

ArrayList<Integer> arr = new ArrayList<>();

2. ArrayList(Collection c): This constructor is used to build an array list initialized with the elements from the collection c.

ArrayList<String> arr = new ArrayList<>(collection);

3. ArrayList(int capacity): This constructor is used to build an array list with the initial capacity being specified.

ArrayList<Double> arr = new ArrayList<>(20);

Advantages of Java ArrayList
----------------------------------
 1 . Dynamic size
 2 . Easy to use
 3 . Fast access
 4 . Ordered collection
 5 . Supports null values

 When to use ArrayList
 -----------------------------
 When you mostly read data (not insert/delete frequently).
 Example: Store users fetched from DB, API responses, dropdown lists,

--------------------------------------------------------------------------------------------------

 Linked List
 ===============

 LinkedList<String> l = new LinkedList<String>();

 Advantages
 ---------------

 A linked list can dynamically grow or shrink in size as needed.
 Adding or removing elements in the middle is efficient since only links need to be updated.
 Doubly linked lists allow traversal in both forward and backward directions.

When to use LinkedList
---------------------------------

When you add/remove items frequently (especially at beginning or middle).
Example: Queues, playlists, undo-history, task scheduling.



 --------------------------------------------------------------------------------------------------------------
| Concept                     | **ArrayList**                      | **LinkedList**                                                        |
| --------------------------- | ---------------------------------- | --------------------------------------------------------------------- |
| **Storage Type**            | Uses **dynamic array** internally. | Uses **doubly linked nodes** (each node stores `data + next + prev`). |
| **Best For**                | Fast random access (get by index). | Fast insertion/deletion in the middle.                                |
| **Access Speed (get)**      | ‚úÖ Very fast (O(1))                 | ‚ùå Slow (O(n))                                                         |
| **Insert/Delete at end**    | ‚úÖ Fast (amortized O(1))            | ‚úÖ Fast (O(1))                                                         |
| **Insert/Delete in middle** | ‚ùå Slow (O(n))                      | ‚úÖ Faster (O(1) after reaching node)                                   |
| **Memory usage**            | Less (just array + values)         | More (extra pointers for next/prev)                                   |
-----------------------------------------------------------------------------------------------------------------

=====================================================================================================================================
                                        SET IMPLEMENTATION
=====================================================================================================

Sets represent collections of unique elements, disallowing duplicates.
They provide implementations with different ordering strategies like hashing, insertion order or sorting.

Insertion order ‚Üí order you inserted elements
Sorted order ‚Üí order based on value comparison (A‚ÄìZ, 1‚ÄìN)
Random order ‚Üí order doesn‚Äôt matter at all

============================================================================================
HASH SET    --fast for add/search/remove operations ‚Äî all happen in roughly O(1) time.
=============

        HashSet<String> userIDs = new HashSet<>();

It is used to store the unique elements and it doesn't maintain any specific order of elements.
Can store the Null values.
HashSet is not thread-safe. To make it thread-safe, synchronization is needed externally.

Uses HashMap (implementation of hash table data structure) internally.
Also implements Serializable and Cloneable interfaces.

| Feature                       | Description                                |
| ----------------------------- | ------------------------------------------ |
| **Duplicates**                | Not allowed                                |
| **Order**                     | Unordered (insertion order not maintained) |
| **Null**                      | Allows only one `null` element             |
| **Underlying Data Structure** | HashMap                                    |
| **Performance**               | Fast because of hashing                    |

‚ö†Ô∏è When to Use HashSet

‚úÖ When you want only unique data
‚úÖ When order doesn‚Äôt matter
‚úÖ When you want fast lookup or removal

üö´ Don‚Äôt use it when:

You need elements in a specific order ‚Üí use LinkedHashSet

You need sorted order ‚Üí use TreeSet
---------------------------------------------------------------------------------------------------
===================
LinkedHashSet
====================

                LinkedHashSet<String> cities = new LinkedHashSet<>();  //‚úÖ Maintained the same order as you inserted

It combines the functionality of a HashSet with a LinkedList to maintain the insertion order of elements.
   -----------------------------------------------------------  -----------------------

Hash table (for fast lookups)
Linked list (for maintaining insertion order)

Insertion order means:
The order in which you add (insert) elements into a collection is the same order in which they‚Äôll come out when you iterate or print them.


Stores unique elements only.
Maintains insertion order.
Provides faster iteration compared to HashSet.
Allows null elements.

Advantages of LinkedHashSet
It maintains insertion order.
It allows quick insertion, deletion and lookup of elements.
It is useful for caching applications where insertion order is important.

-----------------------------------------------------------------------------------------------
Notes:
LinkedHashSet extends HashSet and maintains insertion order.
It inherits most methods from HashSet, AbstractSet, AbstractCollection and Set interface.
Methods like stream(), parallelStream() are useful for working with Java Streams.
retainAll() and removeAll() are useful for performing set operations (intersection and difference).
----------------------------------------------------------------------------------------------------

  | Feature         | HashSet                             | LinkedHashSet                                 |
  | --------------- | ----------------------------------- | --------------------------------------------- |
  | **Order**       | Unordered (random)                  | Maintains insertion order                     |
  | **Duplicates**  | Not allowed                         | Not allowed                                   |
  | **Performance** | Slightly faster                     | Slightly slower (due to linked list overhead) |
  | **When to use** | When you only care about uniqueness | When you need uniqueness + order              |

‚öôÔ∏è When to Use What :

| Scenario                                                     | Use             |
| ------------------------------------------------------------ | --------------- |
| You just want unique items, order doesn‚Äôt matter             | `HashSet`       |
| You want unique items *and* to remember the order of arrival | `LinkedHashSet` |
| You want unique items *and* sorted order (A‚ÄìZ or 1‚ÄìN)        | `TreeSet`       |
------------------------------------------------------------------------------------------------------------------------------
===============
Tree Set
===============

A TreeSet is a collection class that stores unique elements in a sorted order.
part of java.util package that implements the SortedSet interface,
internally uses a Red-Black tree to maintain sorting

TreeSet does not allow duplicate elements; duplicate insertions are ignored.
TreeSet does not allow null values; inserting null throws a NullPointerException.
Implements the NavigableSet interface and provides navigation methods like higher(), lower(), ceiling() and floor().
Not thread-safe; for concurrent access, it must be synchronized using

| Feature                | HashSet         | LinkedHashSet                | TreeSet              |
| ---------------------- | --------------- | ---------------------------- | -------------------- |
| **Order**              | Random          | Insertion order              | Sorted order         |
| **Duplicates**         | ‚ùå               | ‚ùå                            | ‚ùå                    |
| **Null Allowed**       | ‚úÖ (1 null)      | ‚úÖ (1 null)                   | ‚ùå                    |
| **Speed (add/search)** | Fastest         | Fast                         | Slower (log n)       |
| **Best Use Case**      | Just uniqueness | Uniqueness + insertion order | Uniqueness + sorting |

------------------------------------------------------------------------------------------------------------------------

==============
    Queue / Deque Implementations
==============

In Java, a Queue is not a class ‚Äî it‚Äôs an interface that defines behavior.
We can‚Äôt create a Queue object directly ‚Äî we use classes that implement it, like:

LinkedList
PriorityQueue
ArrayDeque

Queues store elements in a FIFO manner,
while Deques allow operations at both ends.
They are used for scheduling, buffering and producer-consumer applications.

    | Implementation            | Description                                        |
    | ------------------------- | -------------------------------------------------- |
    | **LinkedList**            | Common, simple queue implementation                |
    | **PriorityQueue**         | Elements ordered by priority (not insertion order) |
    | **ArrayDeque**            | Faster alternative to LinkedList                   |
    | **ConcurrentLinkedQueue** | Thread-safe version for concurrency                |


    | Method      | Description                                             |
    | ----------- | ------------------------------------------------------- |
    | `add(e)`    | Add element (throws error if full)                      |
    | `offer(e)`  | Add element (returns false if full, safer)              |
    | `remove()`  | Removes and returns head (throws error if empty)        |
    | `poll()`    | Removes and returns head (returns null if empty, safer) |
    | `peek()`    | Returns head without removing (null if empty)           |
    | `element()` | Returns head without removing (throws error if empty)   |

.add() ‚Üí puts person in line
.remove() ‚Üí serves the first person
.peek() ‚Üí shows who‚Äôs next without removing them

====================
    PriorityQueue
====================

        A PriorityQueue doesn‚Äôt care about who came first, it cares about who‚Äôs most important üèÖ

        queue automatically sorts (smallest = highest priority)
        max priority  -- new PriorityQueue<>(Collections.reverseOrder());

 PriorityQueue in Java is a queue where elements are ordered based on their priority,
 rather than the order of insertion

    Uses Heap Data Structure internally.

    Implement min heap (minimum element has the top priority).
    max heap by passing Collections.reverseOrder() while creating an object.

    The size of the Priority Queue is dynamic, which means it increases or decreases as per the requirement.

    | Property                 | Description                                 |
    | ------------------------ | ------------------------------------------- |
    | **Underlying structure** | Min-Heap                                    |
    | **Null values**          | ‚ùå Not allowed                               |
    | **Ordering**             | Based on natural order or custom Comparator |
    | **Duplicates**           | ‚úÖ Allowed                                   |
    | **Not thread-safe**      | Use `PriorityBlockingQueue` for concurrency |

------------------------------------------------------------------------------------------------------------------------
================
    Deque
================

ArrayDeque = Array + Queue hybrid ‚Äî super fast, can act like:

Queue (FIFO)
Stack (LIFO)

‚úÖ You can insert/remove from both sides ‚Äî that‚Äôs why it‚Äôs called Deque (Double-Ended Queue)


| Type                   | Behavior                 | Maintains Order          | Allows Duplicates | Use Case                            |
| ---------------------- | ------------------------ | ------------------------ | ----------------- | ----------------------------------- |
| **Queue (LinkedList)** | FIFO                     | ‚úÖ Yes                    | ‚úÖ Yes             | Ticket lines, waiting queues        |
| **PriorityQueue**      | Based on priority        | ‚öôÔ∏è Depends on comparator | ‚úÖ Yes             | Task scheduling, CPU processes      |
| **ArrayDeque**         | Double-ended (FIFO/LIFO) | ‚úÖ Yes                    | ‚úÖ Yes             | Stack/Queue hybrid, fast operations |

-------------------------------------------------------------------------------------------------------------------

==============================
    Map implementation
==============================

            | Class                 | Difference                              |
            | --------------------- | --------------------------------------- |
            | **LinkedHashMap**     | Maintains insertion order               |
            | **TreeMap**           | Sorted by keys (ascending order)        |
            | **ConcurrentHashMap** | Thread-safe HashMap for multi-threading |
            | **HashTable**         | Legacy version of synchronized HashMap  |


    Maps store data & element in key-value pairs where keys are unique.
    Different implementations provide hashing, ordering, reference-based and concurrent behaviors.


    Default capacity: Default capacity of hashmap is 16.
    Load factor: 0.75 (default): when 75% of the capacity is filled, the capacity is doubled.

    If we try to insert a duplicate, it replaces the existing value of the corresponding key.
    Values can be duplicated.
    Internally uses Hashing, it allows efficient key-based retrieval, insertion, and removal with an average of O(1) time.
    Not synchronized (unlike Hashtable in Java) and hence faster for most cases.
    Allows to store the null keys as well, but there should be only one null key object. Multiple values can be null.

       Note:
        Keys and values in a HashMap cannot be primitive types.

       Keys must be objects that implement hashCode() and equals(), and should be immutable so their hash code and equality remain constant.
       Values can be wrapper classes, custom objects, arrays, reference types, or null.
       Example: Arrays can be used as values but not as keys.


       | Concept                              | Meaning                                        |
       | ------------------------------------ | ---------------------------------------------- |
       | **Key**                              | Unique identifier (like an ID, username, etc.) |
       | **Value**                            | Data associated with the key                   |
       | **put(k, v)**                        | Insert or update a key-value pair              |
       | **get(k)**                           | Retrieve value by key                          |
       | **remove(k)**                        | Delete entry by key                            |
       | **containsKey(k)**                   | Check if key exists                            |
       | **entrySet() / keySet() / values()** | Iterate through map                            |





=============================================================================================



























